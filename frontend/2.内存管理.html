<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script>
            // 内存管理：不管什么语言，在代码的执行过程中都是需要给他分配内存的，不同的是某些编程语言需要我们手动的管理内存，某些编程语言可以自动帮助我们管理内存。

            // 1. 内存的生命周期：不管以何种方式管理内存，内存的管理都有如下生命周期
            //  1.1：分配申请你需要的内存（申请）
            //  1.2：使用分配的内存（存储数据等）
            //  1.3: 不需要使用时,释放内存

            // 手动管理与自动管理的差别在于 1.1和1.3。
            // 手动管理是手动管理内存的申请和释放.
            // 自动管理是自动帮助coder管理内存.

            // JS的内存管理:
            // 1. 分配: js会在定义变量、函数时为我们分配内存。

            //  1.1：js内存分配方式（简略描述，真实会有更细化的划分）
            //      1.1.1 - js对于基本数据类型内存的分配 - 会在执行时，直接在栈空间进行分配。
            //      1.1.2 - js对于复杂数据类型内存的分配 - 会在堆内存中开辟一片空间，并且将这块空间的指针返回作为变量的值。

            // 2. 释放：js的垃圾回收（gc-garbage collection），对于那些不再使用的变量，函数等，就称之为垃圾，需要回收，释放内存空间。
            //  怎样判断一个变量、函数不再使用，是通过gc算法来判断的，常见的gc算法有：
            //      1. 引用计数: 对象中有一块专门的空间-引用计数（retain count）, 用来记录其他对象对它的引用。
            //          有一个引用，它的值就加1. 当引用消失时就减1（如 info.friend = null）.
            //          当 retain count的值为 0 时，gc就会对此空间进行回收。
            //         如下：{ name: 'polar bear' }的retain count 的值就是 3.（变量obj也是一个对 { name: 'polar bear' }的一个引用）
            //          var obj = { name: 'polar bear' };
            //          var info = { name: 'kobe', friend: obj };
            //          var p = { name: 'james', friend: obj };
            //      弊端：产生循环应用导致内存泄露。如 var obj1 = {friend: obj2}  var obj2 = {friend: obj1}

            //      2. 标记清除：这个算法是设置一个根对象（root object）,垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，
            //       对于那些没有引用到的对象，就认为是不可用的对象。这个算法可以很好的解决循环引用的问题。
            // https://boardmix.cn/app/share/CAE.CPHP2QwgASoQgWoYX9dWKZu77iaro58oeDAGQAE/vrMocS

            // js引擎比较广泛的采用的就是标记清除算法，当然类似与V8引擎为了进行更好的优化，它在算法的实现细节上也会结合一些其它的算法。
        </script>
    </body>
</html>
