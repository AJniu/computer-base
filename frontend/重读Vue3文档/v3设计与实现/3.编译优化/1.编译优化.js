// 编译优化：
// 作用:编译器将模板编译为渲染函数过程中,尽可能多地提取关键信息,并借此生成最优代码的过程.

// 一:动态节点收集与补丁标志
// 响应式dom-D1:
// <div id="root">
//   <p class="bar">{{ text }}</p>
// <div />;
// 1.diff算法的问题
// 以D1为例，当text发生更改时，diff算法会逐层遍历，修改响应式内容。
// 但实际唯一有可能变化的是p标签的文本子节点的内容，即当text发生变化时，直接修改p的文本内容最高效。
// 但diff算法做不到，而这可以通过编译优化做到。

// 直接更新可能变化的内容 的实现:
// 实际上模板的结构非常稳定。通过编译手段，可以分析出哪些节点是静态的(静态内容)，哪些节点是动态的(动态内容)。
// 结合这些关键信息,编译器可以直接生成原生dom操作的代码.
// (甚至能抛掉虚拟dom，避免虚拟dom的性能开销。-由于渲染函数的灵活性和vue版本兼容性，暂时没这么做，vueConf分享提到了想做无虚拟dom的vue)
// vue3的编译器将编译时得到的这些关键信息“附着”在它的生成的虚拟dom上，这些信息会随着虚拟dom传递给渲染器，
// 最终渲染器会根据这些关键信息执行"快捷操作",从而提升运行时性能.

// 2.Block 和 PatchFlags：
// 当运行时可以区分静态内容和动态内容时,即可实现极致的优化策略。如下：
// 响应式dom-D2:
// <div>
//   <span>静态内容</span>
//   <p>{{ text }}</p>
// <div />;
// 最效率变更：当text变化时，只更新p标签的文本内容

// D2 传统的虚拟dom
// const D2VNode = {
//   type: 'div',
//   children: [
//     { type: 'span', children: '静态内容' },
//     { type: 'p', children: ctx.text },
//   ],
// };
// D2 以patchFlag为动态标志的虚拟dom
const D2VNode = {
  type: 'div',
  children: [
    { type: 'span', children: '静态内容' },
    { type: 'p', children: ctx.text, patchFlag: 1 }, // patchFlag为1，代表动态内容
  ],
};
